// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.kauailabs.navx.frc.AHRS;
import com.swervedrivespecialties.swervelib.ModuleConfiguration;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveDriveOdometry;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotMap;


/**
 *
 */
public class DriveSubsystem extends SubsystemBase {
   
    public static final double TRACKWIDTH = 19.5 * 0.0254; //distance between the left and right wheels
    public static final double WHEELBASE = 23.5 * 0.0254; //front to back distance
    public static final double MAX_SPEED = 5.0; // m/s 
    public static final Pose2d defaultStartPosition = new Pose2d(0, 0, Rotation2d.fromDegrees(0));

    private static final double FRONT_LEFT_ANGLE_OFFSET = Math.toRadians(209.787-180.0);
    private static final double FRONT_RIGHT_ANGLE_OFFSET = Math.toRadians(151.43 );
    private static final double BACK_LEFT_ANGLE_OFFSET = Math.toRadians(303.485 - 180.0);
    private static final double BACK_RIGHT_ANGLE_OFFSET = Math.toRadians(342.33 );
    private static final double kPgain = 0.080;
    private static final double kDgain = 0;
    public double FLcommandedAngle;
    public double BLcommandedAngle;
    public double BRcommandedAngle;
    public double FRcommandedAngle;
    

    private static DriveSubsystem m_instance;

    private SwerveDriveOdometry mOdometry;

    ModuleConfiguration rightSideConfiguration = new ModuleConfiguration(
        0.10033,
        (14.0 / 50.0) * (27.0 / 17.0) * (15.0 / 45.0),
        true,
        (9.0 / 24.0) * (14.0 / 72.0),
        true );

    ModuleConfiguration leftSideConfiguration = new ModuleConfiguration(
        0.10033,
        (14.0 / 50.0) * (27.0 / 17.0) * (15.0 / 45.0),
        false,
        (9.0 / 24.0) * (14.0 / 72.0),
        true );
    
        private final TTSwerveModule frontLeftModule = new TTSwerveModule(
                                                        leftSideConfiguration,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_ENCODER,
                                                        FRONT_LEFT_ANGLE_OFFSET );
    private final TTSwerveModule frontRightModule = new TTSwerveModule(
                                                        rightSideConfiguration,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_ENCODER,
                                                        FRONT_RIGHT_ANGLE_OFFSET );

    private final TTSwerveModule backLeftModule  = new TTSwerveModule(
                                                        leftSideConfiguration,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_ENCODER,
                                                        BACK_LEFT_ANGLE_OFFSET );

    private final TTSwerveModule backRightModule =  new TTSwerveModule(
                                                        rightSideConfiguration,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_ENCODER,
                                                        BACK_RIGHT_ANGLE_OFFSET );
                         
                        
    private final SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
            new Translation2d(-WHEELBASE / 2.0, TRACKWIDTH / 2.0),  //front left
            new Translation2d(-WHEELBASE / 2.0, -TRACKWIDTH / 2.0), //front right
            new Translation2d(WHEELBASE / 2.0, TRACKWIDTH / 2.0), //back  left
            new Translation2d(WHEELBASE / 2.0, -TRACKWIDTH / 2.0) //back  right
    );

    private final AHRS ahrs = new AHRS(SerialPort.Port.kUSB);
    private Pose2d m_pose;
 
    public DriveSubsystem() {
        m_instance = this;    

        ahrs.reset();


        mOdometry = new SwerveDriveOdometry(
            kinematics, Rotation2d.fromRadians(getAngleRad()),
            new SwerveModulePosition[] {
              frontLeftModule.getPosition(),
              frontRightModule.getPosition(),
              backLeftModule.getPosition(),
              backRightModule.getPosition()
            }, defaultStartPosition);
            
    }

    public static DriveSubsystem getInstance() {
        if (m_instance == null) {
            m_instance = new DriveSubsystem();
        }

        return m_instance;
    }

    @Override
    public void periodic() {
        // Get the rotation of the robot from the gyro.
        var gyroAngle = Rotation2d.fromRadians(getAngleRad());

         // Update the pose
         m_pose = mOdometry.update(gyroAngle,
                        new SwerveModulePosition[] {
                        frontLeftModule.getPosition(), frontRightModule.getPosition(),
                        backLeftModule.getPosition(), backRightModule.getPosition()
                        });


        SmartDashboard.putString("frontleft", frontLeftModule.getPosition().toString());
        SmartDashboard.putString("frontRight", frontRightModule.getPosition().toString());
        SmartDashboard.putString("backLeft", backLeftModule.getPosition().toString());
        SmartDashboard.putString("backRight", backRightModule.getPosition().toString());
        SmartDashboard.putNumber("Front Left Module Angle", Math.toDegrees(frontLeftModule.getSteerAngle()));
        SmartDashboard.putNumber("Front Right Module Angle", Math.toDegrees(frontRightModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Left Module Angle", Math.toDegrees(backLeftModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Right Module Angle", Math.toDegrees(backRightModule.getSteerAngle()));                 
        SmartDashboard.putNumber("Front Left Commanded Angle", FLcommandedAngle);
     SmartDashboard.putNumber("Front Right Commanded Angle", FRcommandedAngle);
    SmartDashboard.putNumber("Back Left Commanded Angle", BLcommandedAngle);
       SmartDashboard.putNumber("Back Right Commanded Angle", BRcommandedAngle);            
        


        // SmartDashboard.putNumber("Gyroscope Angle", ahrs.getYaw());
        // SmartDashboard.putNumber("Gyroscope Pitch", ahrs.getPitch());

        SmartDashboard.putString("Pose:", m_pose.toString());

    }

    public Pose2d getPose2d(){
        return m_pose;
    }

    public void setPose2d(Pose2d pose){
        m_pose = pose;
    }

    public void driveHeading(Translation2d translation, double heading) {

        double angle = getAngleDeg();
		double currentAngularRate = getAngularRateDegPerSec();
		double angle_error = angleDeltaDeg(heading, angle);
		double yawCommand = - angle_error * kPgain - (currentAngularRate) * kDgain;

        drive(translation, yawCommand, true);
    }


    public void drive(Translation2d translation, double rotation, boolean fieldOriented) {

        translation = translation.times(MAX_SPEED);
        rotation *= 2.0 / Math.hypot(WHEELBASE, TRACKWIDTH);
        ChassisSpeeds speeds;
        if (fieldOriented) {
            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(translation.getX(), -translation.getY(), rotation,
                    Rotation2d.fromDegrees(ahrs.getAngle()));
        } else {
            speeds = new ChassisSpeeds(translation.getX(), -translation.getY(), rotation);
        }


        SwerveModuleState[] states = kinematics.toSwerveModuleStates(speeds);
        frontLeftModule.set(states[0].speedMetersPerSecond, states[0].angle.getRadians());
        frontRightModule.set(states[1].speedMetersPerSecond, states[1].angle.getRadians());
        backLeftModule.set(states[2].speedMetersPerSecond, states[2].angle.getRadians());
        backRightModule.set(states[3].speedMetersPerSecond, states[3].angle.getRadians());
        //TODO we'd really like to set the velocity in m/s

        

       FLcommandedAngle = states[0].angle.getDegrees();
       FRcommandedAngle = states[1].angle.getDegrees();
       BLcommandedAngle = states[2].angle.getDegrees();
       BRcommandedAngle = states[3].angle.getDegrees();

     
    }
    
    public void setAll(double speed, double angleRadians) {
        frontLeftModule.set(speed, angleRadians);
        frontRightModule.set(speed, angleRadians);
        backLeftModule.set(speed, angleRadians);
        backRightModule.set(speed, angleRadians);
        //SmartDashboard.putNumber("Front Left Commanded Angle", Math.toDegrees(angleRadians));
       //SmartDashboard.putNumber("Front Right Commanded Angle", Math.toDegrees(angleRadians));
        //SmartDashboard.putNumber("Back Left Commanded Angle", Math.toDegrees(angleRadians));
        //SmartDashboard.putNumber("Back Right Commanded Angle", Math.toDegrees(angleRadians));
    }


    public void resetGyroscope() {
        ahrs.setAngleAdjustment(ahrs.getAngle() - ahrs.getAngleAdjustment());
    }

    public double getPitchDeg() {
       return ahrs.getPitch();
    }

    public double getAngleDeg() {
        return -ahrs.getAngle();
    }

    public double getAngleRad(){
        return Math.toRadians(getAngleDeg());
    }

    public void setAngleDeg(double robotangle) {
        double angle2 = -robotangle;
        double err = angle2 - ahrs.getAngle();
        double newAdj = err + ahrs.getAngleAdjustment();
        ahrs.setAngleAdjustment(newAdj);
    }

    public double getAngularRateDegPerSec() {
        return -ahrs.getRate();
    }

    public Translation2d getVelocityVector(){
        Translation2d v1 = new Translation2d(frontLeftModule.getDriveVelocity(), 
                                         Rotation2d.fromRadians(frontLeftModule.getAbsoluteAngle()));
        Translation2d v2 = new Translation2d(backRightModule.getDriveVelocity(),
                                         Rotation2d.fromRadians(backLeftModule.getAbsoluteAngle()));
        return v1.plus(v2).div(2);
    }

    static public double angleDeltaDeg(double src, double dest) {
		double delta = (dest - src) % 360.0;
		if(Math.abs(delta) > 180) {
			delta = delta - (Math.signum(delta) * 360);
		}
		return delta;
    }
    
    public void calibrateSterrRelativeEncoder(){
        frontLeftModule.calibrateSterrRelativeEncoder();
        frontRightModule.calibrateSterrRelativeEncoder();
        backLeftModule.calibrateSterrRelativeEncoder();
        backRightModule.calibrateSterrRelativeEncoder();
    }

    public void stop() {
        frontLeftModule.set(0, Math.PI/4);
        frontRightModule.set(0, -Math.PI/4);
        backLeftModule.set(0, -Math.PI/4);
        backRightModule.set(0, Math.PI);
    }
}

//TODO Create a stop method for the drivetrain