// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.kauailabs.navx.frc.AHRS;
import com.swervedrivespecialties.swervelib.ModuleConfiguration;

import au.grapplerobotics.ConfigurationFailedException;
import au.grapplerobotics.LaserCan;
import au.grapplerobotics.interfaces.LaserCanInterface.Measurement;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveDriveOdometry;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.DriveConstants;
import frc.robot.RobotMap;


/**
 *
 */
public class DriveSubsystem extends SubsystemBase {
   
    public static final double TRACKWIDTH = 19.5 * 0.0254; //distance between the left and right wheels
    public static final double WHEELBASE = 23.5 * 0.0254; //front to back distance
    public static final double MAX_SPEED = 5.0; // m/s 
    public static final Pose2d defaultStartPosition = new Pose2d(0, 0, Rotation2d.fromDegrees(0));

    private static final double FRONT_LEFT_ANGLE_OFFSET = Math.toRadians(209.787-180.0);
    private static final double FRONT_RIGHT_ANGLE_OFFSET = Math.toRadians(151.43 );
    private static final double BACK_LEFT_ANGLE_OFFSET = Math.toRadians(303.485 - 180.0);
    private static final double BACK_RIGHT_ANGLE_OFFSET = Math.toRadians(342.33 );
    private static final double kPgain = 0.080;
    private static final double kDgain = 0;
    public double FLcommandedAngle;
    public double BLcommandedAngle;
    public double BRcommandedAngle;
    public double FRcommandedAngle;
    
    private LaserCan dxSensor = new LaserCan(RobotMap.DRIVETRAIN_DX_SENSOR);

    private static DriveSubsystem m_instance;

    private SwerveDriveOdometry mOdometry;

    ModuleConfiguration rightSideConfiguration = new ModuleConfiguration(
        0.10033,
        (14.0 / 50.0) * (27.0 / 17.0) * (15.0 / 45.0),
        true,
        (9.0 / 24.0) * (14.0 / 72.0),
        true );

    ModuleConfiguration leftSideConfiguration = new ModuleConfiguration(
        0.10033,
        (14.0 / 50.0) * (27.0 / 17.0) * (15.0 / 45.0),
        false,
        (9.0 / 24.0) * (14.0 / 72.0),
        true );
    
        private final TTSwerveModule frontLeftModule = new TTSwerveModule(
                                                        leftSideConfiguration,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_ENCODER,
                                                        FRONT_LEFT_ANGLE_OFFSET );
    private final TTSwerveModule frontRightModule = new TTSwerveModule(
                                                        rightSideConfiguration,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_ENCODER,
                                                        FRONT_RIGHT_ANGLE_OFFSET );

    private final TTSwerveModule backLeftModule  = new TTSwerveModule(
                                                        leftSideConfiguration,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_ENCODER,
                                                        BACK_LEFT_ANGLE_OFFSET );

    private final TTSwerveModule backRightModule =  new TTSwerveModule(
                                                        rightSideConfiguration,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_ENCODER,
                                                        BACK_RIGHT_ANGLE_OFFSET );
                         
                        
    private final SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
            new Translation2d(-WHEELBASE / 2.0, TRACKWIDTH / 2.0),  //front left
            new Translation2d(-WHEELBASE / 2.0, -TRACKWIDTH / 2.0), //front right
            new Translation2d(WHEELBASE / 2.0, TRACKWIDTH / 2.0), //back  left
            new Translation2d(WHEELBASE / 2.0, -TRACKWIDTH / 2.0) //back  right
    );

    private final AHRS ahrs = new AHRS(SerialPort.Port.kUSB);
    private Pose2d m_pose;
 
    public DriveSubsystem() {
        m_instance = this;    

        ahrs.reset();


        mOdometry = new SwerveDriveOdometry(
            kinematics, Rotation2d.fromRadians(getAngleRad()),
            new SwerveModulePosition[] {
              frontLeftModule.getPosition(),
              frontRightModule.getPosition(),
              backLeftModule.getPosition(),
              backRightModule.getPosition()
            }, defaultStartPosition);
            
        try {
            dxSensor.setRangingMode(LaserCan.RangingMode.LONG);
            dxSensor.setRegionOfInterest(new LaserCan.RegionOfInterest(8, 8, 16, 16));
            dxSensor.setTimingBudget(LaserCan.TimingBudget.TIMING_BUDGET_33MS);
        } catch (ConfigurationFailedException e) {
            System.out.println("LaserCan Configuration failed! " + e);
        }
    }

    public static DriveSubsystem getInstance() {
        if (m_instance == null) {
            m_instance = new DriveSubsystem();
        }

        return m_instance;
    }

    @Override
    public void periodic() {
        // Get the rotation of the robot from the gyro.
        var gyroAngle = Rotation2d.fromRadians(getAngleRad());


         // Update the pose
      //   m_pose = mOdometry.update(gyroAngle,
      //                  new SwerveModulePosition[] {
      //                  frontLeftModule.getPosition(), frontRightModule.getPosition(),
      //                  backLeftModule.getPosition(), backRightModule.getPosition()
      //                  });

      SmartDashboard.putNumber("Heading", getAngleDeg());
      SmartDashboard.putNumber("lCan Distance", getDistanceToObjectMeters());
      SmartDashboard.putBoolean("lCan ready", distanceMeasurmentGood());

    }

    public Pose2d getPose(){
        return m_pose;
    }

    public void setPose(Pose2d pose){
        m_pose = pose;
    }

    public double turnToHeading(double heading){
        double angle = getAngleDeg();
		double currentAngularRate = getAngularRateDegPerSec();
		double angle_error = angleDeltaDeg(heading, angle);
		double yawCommand = - angle_error * kPgain - (currentAngularRate) * kDgain;
        return yawCommand;       
    }
    
    public void driveHeadingField(Translation2d translation, double heading) {
        double yawCommand = turnToHeading(heading);
        drive(translation, yawCommand, true);
    }

    
    public void driveHeadingRobot(Translation2d translation, double heading) {
        double yawCommand = turnToHeading(heading);
        drive(translation, yawCommand, false);
    }

    public void drive( double x, double y, double rotation, boolean fieldOriented, boolean fake) {
        drive(new Translation2d(x, y), rotation, fieldOriented);
    }   

    public void drive(Translation2d translation, double rotation) {        
        drive(translation, rotation, true);
    }

    public void drive(Translation2d translation, double rotation, boolean fieldOriented) {

        translation = translation.times(MAX_SPEED);
        rotation *= 2.0 / Math.hypot(WHEELBASE, TRACKWIDTH);
        ChassisSpeeds speeds;
        if (fieldOriented) {
            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(translation.getX(), -translation.getY(), rotation,
                    Rotation2d.fromDegrees(ahrs.getAngle()));
        } else {
            speeds = new ChassisSpeeds(translation.getX(), -translation.getY(), rotation);
        }


        SwerveModuleState[] states = kinematics.toSwerveModuleStates(speeds);
        frontLeftModule.set(states[0].speedMetersPerSecond, states[0].angle.getRadians());
        frontRightModule.set(states[1].speedMetersPerSecond, states[1].angle.getRadians());
        backLeftModule.set(states[2].speedMetersPerSecond, states[2].angle.getRadians());
        backRightModule.set(states[3].speedMetersPerSecond, states[3].angle.getRadians());
        //TODO we'd really like to set the velocity in m/s

        

       FLcommandedAngle = states[0].angle.getDegrees();
       FRcommandedAngle = states[1].angle.getDegrees();
       BLcommandedAngle = states[2].angle.getDegrees();
       BRcommandedAngle = states[3].angle.getDegrees();

     
    }
    
    public void setAll(double speed, double angleRadians) {
        frontLeftModule.set(speed, angleRadians);
        frontRightModule.set(speed, angleRadians);
        backLeftModule.set(speed, angleRadians);
        backRightModule.set(speed, angleRadians);
        //SmartDashboard.putNumber("Front Left Commanded Angle", Math.toDegrees(angleRadians));
       //SmartDashboard.putNumber("Front Right Commanded Angle", Math.toDegrees(angleRadians));
        //SmartDashboard.putNumber("Back Left Commanded Angle", Math.toDegrees(angleRadians));
        //SmartDashboard.putNumber("Back Right Commanded Angle", Math.toDegrees(angleRadians));
    }


    public void resetGyroscope() {
        ahrs.setAngleAdjustment(ahrs.getAngle() - ahrs.getAngleAdjustment());
    }

    public double getPitchDeg() {
       return ahrs.getPitch();
    }

    public double getAngleDeg() {
        return -ahrs.getAngle();
    }

    public double getAngleRad(){
        return Math.toRadians(getAngleDeg());
    }

    public void setAngleDeg(double robotangle) {
        double angle2 = -robotangle;
        double err = angle2 - ahrs.getAngle();
        double newAdj = err + ahrs.getAngleAdjustment();
        ahrs.setAngleAdjustment(newAdj);
    }

    public double getAngularRateDegPerSec() {
        return -ahrs.getRate();
    }

    public Translation2d getVelocityVector(){
        Translation2d v1 = new Translation2d(frontLeftModule.getDriveVelocity(), 
                                         Rotation2d.fromRadians(frontLeftModule.getAbsoluteAngle()));
        Translation2d v2 = new Translation2d(backRightModule.getDriveVelocity(),
                                         Rotation2d.fromRadians(backLeftModule.getAbsoluteAngle()));
        return v1.plus(v2).div(2);
    }

    static public double angleDeltaDeg(double src, double dest) {
		double delta = (dest - src) % 360.0;
		if(Math.abs(delta) > 180) {
			delta = delta - (Math.signum(delta) * 360);
		}
		return delta;
    }
    
    public void calibrateSterrRelativeEncoder(){
        frontLeftModule.calibrateSterrRelativeEncoder();
        frontRightModule.calibrateSterrRelativeEncoder();
        backLeftModule.calibrateSterrRelativeEncoder();
        backRightModule.calibrateSterrRelativeEncoder();
    }

    public void stop() {
        frontLeftModule.set(0, Math.PI/4);
        frontRightModule.set(0, -Math.PI/4);
        backLeftModule.set(0, -Math.PI/4);
        backRightModule.set(0, Math.PI);
    }

    public double getSpeed(){
    ChassisSpeeds chassisSpeeds =  DriveConstants.kDriveKinematics.toChassisSpeeds(
                                          frontLeftModule.getState(),
                                          frontRightModule.getState(),
                                          backLeftModule.getState(),
                                          backRightModule.getState());
    return Math.hypot(chassisSpeeds.vxMetersPerSecond, chassisSpeeds.vyMetersPerSecond);
  }

  public void setX(){ stop(); }

  public void resetOdometry(Pose2d pose) {
    mOdometry.resetPosition(
        Rotation2d.fromDegrees(getAngleDeg()),
        new SwerveModulePosition[] {
            frontLeftModule.getPosition(),
            frontRightModule.getPosition(),
            backLeftModule.getPosition(),
            backRightModule.getPosition()
        },
        pose);
  }

  public Double getDistanceToObjectMeters(){
    Measurement m = dxSensor.getMeasurement();
    return m.distance_mm * 0.001;
  }

  public boolean distanceMeasurmentGood(){
    Measurement m = dxSensor.getMeasurement();
    return m.status == LaserCan.LASERCAN_STATUS_VALID_MEASUREMENT;
  }
}

//TODO Create a stop method for the drivetrain